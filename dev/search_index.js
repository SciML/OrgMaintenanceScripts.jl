var documenterSearchIndex = {"docs":
[{"location":"version_check_finder/#Version-Check-Finder","page":"Version Check Finder","title":"Version Check Finder","text":"","category":"section"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"The Version Check Finder functionality helps identify and remove obsolete Julia version compatibility checks from your codebase.","category":"page"},{"location":"version_check_finder/#Overview","page":"Version Check Finder","title":"Overview","text":"","category":"section"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"When Julia releases new versions, older version checks become obsolete. For example, with Julia 1.10 as the current LTS, checks for versions older than 1.10 are no longer needed. This module helps you:","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"Find obsolete version checks\nGenerate scripts to review them\nAutomatically create PRs to remove them","category":"page"},{"location":"version_check_finder/#Functions","page":"Version Check Finder","title":"Functions","text":"","category":"section"},{"location":"version_check_finder/#Finding-Version-Checks","page":"Version Check Finder","title":"Finding Version Checks","text":"","category":"section"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"find_version_checks_in_file(filepath::String; min_version::VersionNumber=v\"1.10\")","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"Find version checks in a single file that compare against versions older than min_version.","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"find_version_checks_in_repo(repo_path::String; min_version::VersionNumber=v\"1.10\", ignore_dirs=[\"test\", \"docs\", \".git\"])","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"Find version checks in an entire repository.","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"find_version_checks_in_org(org::String; min_version::VersionNumber=v\"1.10\", auth_token::String=\"\", work_dir::String=mktempdir())","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"Find version checks across all repositories in a GitHub organization.","category":"page"},{"location":"version_check_finder/#Writing-Results-to-Scripts","page":"Version Check Finder","title":"Writing Results to Scripts","text":"","category":"section"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"write_version_checks_to_script(checks::Vector{VersionCheck}, output_file::String=\"fix_version_checks.jl\")","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"Write version check results to an executable Julia script for review and manual fixes.","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"write_org_version_checks_to_script(org_results::Dict{String, Vector{VersionCheck}}, output_file::String=\"fix_org_version_checks.jl\")","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"Write organization-wide results to a script.","category":"page"},{"location":"version_check_finder/#Automated-Fixing","page":"Version Check Finder","title":"Automated Fixing","text":"","category":"section"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"fix_version_checks_parallel(checks::Vector{VersionCheck}, n_processes::Int=4; github_token::String=\"\", base_branch::String=\"main\")","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"Fix version checks in parallel using N processes. Each process creates a PR to remove obsolete checks.","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"fix_org_version_checks_parallel(org::String, n_processes::Int=4; min_version::VersionNumber=v\"1.10\", github_token::String=\"\")","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"Find and fix version checks across an entire organization using parallel processing.","category":"page"},{"location":"version_check_finder/#Supported-Patterns","page":"Version Check Finder","title":"Supported Patterns","text":"","category":"section"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"The finder detects these version check patterns:","category":"page"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"if VERSION >= v\"1.6\"\n@static if VERSION > v\"1.8.0\"\nVERSION <= v\"1.9\"\nVERSION == v\"1.7\"\nVERSION >= VersionNumber(\"1.6\")","category":"page"},{"location":"version_check_finder/#Usage-Examples","page":"Version Check Finder","title":"Usage Examples","text":"","category":"section"},{"location":"version_check_finder/#Find-checks-in-a-single-repository","page":"Version Check Finder","title":"Find checks in a single repository","text":"","category":"section"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"using OrgMaintenanceScripts\n\n# Find all version checks older than Julia 1.10\nchecks = find_version_checks_in_repo(\"/path/to/repo\")\n\n# Write results to a script\nwrite_version_checks_to_script(checks, \"fix_my_checks.jl\")","category":"page"},{"location":"version_check_finder/#Process-an-entire-organization","page":"Version Check Finder","title":"Process an entire organization","text":"","category":"section"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"# Set up GitHub token\ngithub_token = ENV[\"GITHUB_TOKEN\"]\n\n# Find and fix all obsolete version checks\nresults = fix_org_version_checks_parallel(\"JuliaLang\", 4; \n    github_token=github_token,\n    min_version=v\"1.10\"\n)","category":"page"},{"location":"version_check_finder/#Custom-minimum-version","page":"Version Check Finder","title":"Custom minimum version","text":"","category":"section"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"# Find checks older than Julia 1.11\nchecks = find_version_checks_in_repo(\"/path/to/repo\"; min_version=v\"1.11\")","category":"page"},{"location":"version_check_finder/#Best-Practices","page":"Version Check Finder","title":"Best Practices","text":"","category":"section"},{"location":"version_check_finder/","page":"Version Check Finder","title":"Version Check Finder","text":"Always review the generated scripts before applying fixes\nTest your code after removing version checks\nConsider keeping version checks in test files for compatibility testing\nUse GitHub authentication for better API rate limits\nStart with a single repository before processing entire organizations","category":"page"},{"location":"compat_bumping/#Compat-Bumping","page":"Compat Bumping","title":"Compat Bumping","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"OrgMaintenanceScripts.jl provides functionality to automatically check for major version updates of dependencies, test them locally, and create pull requests if tests pass.","category":"page"},{"location":"compat_bumping/#Overview","page":"Compat Bumping","title":"Overview","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"The compat bumping functionality helps maintain Julia packages by:","category":"page"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"Detecting when dependencies have new major versions available\nAutomatically updating compat entries to allow the new versions\nRunning tests locally to ensure compatibility\nCreating pull requests if tests pass","category":"page"},{"location":"compat_bumping/#Functions","page":"Compat Bumping","title":"Functions","text":"","category":"section"},{"location":"compat_bumping/#get_available_compat_updates","page":"Compat Bumping","title":"get_available_compat_updates","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"Check for available major version updates in a package's dependencies.","category":"page"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"updates = get_available_compat_updates(\"Project.toml\")","category":"page"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"Returns a vector of CompatUpdate structs, each containing:","category":"page"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"package_name: Name of the dependency\ncurrent_compat: Current compat specification\nlatest_version: Latest available version\nis_major_update: Whether this is a major version bump","category":"page"},{"location":"compat_bumping/#bump_compat_and_test","page":"Compat Bumping","title":"bump_compat_and_test","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"Bump compat entries for major version updates and run tests locally.","category":"page"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"success, message, pr_url, bumped_packages = bump_compat_and_test(\"path/to/repo\";\n    package_name = \"SpecificPackage\",  # Optional: bump only this package\n    bump_all = false,                  # Bump all available updates\n    create_pr = true,                  # Create PR if tests pass\n    fork_user = \"yourusername\"         # Required for PR creation\n)","category":"page"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"Arguments:","category":"page"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"repo_path: Path to the repository\npackage_name: Specific package to bump (optional)\nbump_all: Whether to bump all available updates or just one\ncreate_pr: Whether to create a PR if tests pass\nfork_user: GitHub username for creating PRs","category":"page"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"Returns:","category":"page"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"success: Whether the operation succeeded\nmessage: Status message\npr_url: URL of created PR (if any)\nbumped_packages: List of packages that were bumped","category":"page"},{"location":"compat_bumping/#bump_compat_org_repositories","page":"Compat Bumping","title":"bump_compat_org_repositories","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"Process all repositories in a GitHub organization.","category":"page"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"successes, failures, pr_urls = bump_compat_org_repositories(\"SciML\";\n    package_name = nothing,      # Bump all packages\n    bump_all = false,           # One update per repo\n    create_pr = true,\n    fork_user = \"yourusername\",\n    limit = 100,\n    log_file = \"compat_bump.log\"\n)","category":"page"},{"location":"compat_bumping/#Examples","page":"Compat Bumping","title":"Examples","text":"","category":"section"},{"location":"compat_bumping/#Check-for-Updates","page":"Compat Bumping","title":"Check for Updates","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"using OrgMaintenanceScripts\n\n# Check what updates are available\nupdates = get_available_compat_updates(\"Project.toml\")\nfor update in updates\n    println(\"$(update.package_name): $(update.current_compat) → $(update.latest_version)\")\nend","category":"page"},{"location":"compat_bumping/#Bump-Single-Package","page":"Compat Bumping","title":"Bump Single Package","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"# Bump compat for DataFrames only\nsuccess, msg, pr_url, bumped = bump_compat_and_test(\".\";\n    package_name = \"DataFrames\",\n    create_pr = true,\n    fork_user = \"myusername\"\n)","category":"page"},{"location":"compat_bumping/#Bump-All-Updates","page":"Compat Bumping","title":"Bump All Updates","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"# Bump all available major version updates\nsuccess, msg, pr_url, bumped = bump_compat_and_test(\".\";\n    bump_all = true,\n    create_pr = true,\n    fork_user = \"myusername\"\n)","category":"page"},{"location":"compat_bumping/#Process-Organization","page":"Compat Bumping","title":"Process Organization","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"# Process all SciML repositories\nsuccesses, failures, pr_urls = bump_compat_org_repositories(\"SciML\";\n    bump_all = false,  # One update per repo\n    create_pr = true,\n    fork_user = \"myusername\",\n    limit = 50\n)\n\nprintln(\"Successfully updated: $(length(successes)) repos\")\nprintln(\"Failed: $(length(failures)) repos\")\nprintln(\"Created $(length(pr_urls)) pull requests\")","category":"page"},{"location":"compat_bumping/#Workflow","page":"Compat Bumping","title":"Workflow","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"Detection: The tool scans Project.toml to find dependencies with new major versions\nUpdate: Compat entries are updated to allow the new major version\nTest: The package's tests are run locally with the updated dependencies\nPR Creation: If tests pass, a pull request is automatically created","category":"page"},{"location":"compat_bumping/#Requirements","page":"Compat Bumping","title":"Requirements","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"Julia 1.6 or later\nGitHub CLI (gh) installed and authenticated for PR creation\nWrite access to a fork of the repositories you want to update","category":"page"},{"location":"compat_bumping/#Notes","page":"Compat Bumping","title":"Notes","text":"","category":"section"},{"location":"compat_bumping/","page":"Compat Bumping","title":"Compat Bumping","text":"The tool only creates PRs for updates where tests pass\nTests have a default timeout of 30 minutes (configurable)\nRate limiting is applied when processing multiple repositories\nLogs are saved for organization-wide operations","category":"page"},{"location":"formatting/#Formatting-Maintenance","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"The OrgMaintenanceScripts package provides automated formatting functionality to maintain consistent code style across SciML repositories using JuliaFormatter.","category":"page"},{"location":"formatting/#Functions","page":"Formatting Maintenance","title":"Functions","text":"","category":"section"},{"location":"formatting/#format_repository","page":"Formatting Maintenance","title":"format_repository","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"Format a single repository with JuliaFormatter.","category":"page"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"format_repository(repo_url::String; \n                 test::Bool = true,\n                 push_to_master::Bool = false,\n                 create_pr::Bool = true,\n                 fork_user::String = \"\",\n                 working_dir::String = mktempdir())","category":"page"},{"location":"formatting/#Arguments","page":"Formatting Maintenance","title":"Arguments","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"repo_url: URL of the repository to format (e.g., \"https://github.com/SciML/Example.jl.git\")\ntest: Whether to run tests after formatting (default: true)\npush_to_master: Whether to push directly to master/main if tests pass (default: false)\ncreate_pr: Whether to create a PR instead of pushing to master (default: true)\nfork_user: GitHub username for creating PRs (required if create_pr=true)\nworking_dir: Directory to clone the repository into (default: temporary directory)","category":"page"},{"location":"formatting/#Returns","page":"Formatting Maintenance","title":"Returns","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"(success::Bool, message::String, pr_url::Union{String,Nothing})","category":"page"},{"location":"formatting/#Example","page":"Formatting Maintenance","title":"Example","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"# Format a repository and create a PR\nsuccess, message, pr_url = format_repository(\n    \"https://github.com/SciML/Example.jl.git\";\n    test = true,\n    create_pr = true,\n    fork_user = \"myusername\"\n)\n\nif success\n    println(\"PR created: $pr_url\")\nelse\n    println(\"Failed: $message\")\nend","category":"page"},{"location":"formatting/#format_org_repositories","page":"Formatting Maintenance","title":"format_org_repositories","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"Format all repositories in a GitHub organization.","category":"page"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"format_org_repositories(org::String = \"SciML\";\n                       test::Bool = true,\n                       push_to_master::Bool = false,\n                       create_pr::Bool = true,\n                       fork_user::String = \"\",\n                       limit::Int = 100,\n                       only_failing_ci::Bool = true,\n                       log_file::String = \"\")","category":"page"},{"location":"formatting/#Arguments-2","page":"Formatting Maintenance","title":"Arguments","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"org: GitHub organization name (default: \"SciML\")\ntest: Whether to run tests after formatting (default: true)\npush_to_master: Whether to push directly to master/main if tests pass (default: false)\ncreate_pr: Whether to create PRs instead of pushing to master (default: true)\nfork_user: GitHub username for creating PRs (required if create_pr=true)\nlimit: Maximum number of repositories to process (default: 100)\nonly_failing_ci: Only process repos with failing formatter CI (default: true)\nlog_file: Path to save results log (default: auto-generated)","category":"page"},{"location":"formatting/#Returns-2","page":"Formatting Maintenance","title":"Returns","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"(successes::Vector{String}, failures::Vector{String}, pr_urls::Vector{String})","category":"page"},{"location":"formatting/#Example-2","page":"Formatting Maintenance","title":"Example","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"# Format all SciML repos with failing formatter CI\nsuccesses, failures, pr_urls = format_org_repositories(\n    \"SciML\";\n    test = false,  # Skip tests for speed\n    create_pr = true,\n    fork_user = \"myusername\",\n    only_failing_ci = true\n)\n\nprintln(\"Successfully formatted: $(length(successes)) repositories\")\nprintln(\"Failed: $(length(failures)) repositories\")\nprintln(\"Created $(length(pr_urls)) pull requests\")","category":"page"},{"location":"formatting/#Usage-Scenarios","page":"Formatting Maintenance","title":"Usage Scenarios","text":"","category":"section"},{"location":"formatting/#1.-Regular-Maintenance-(Recommended)","page":"Formatting Maintenance","title":"1. Regular Maintenance (Recommended)","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"Create PRs for repositories with failing formatter CI:","category":"page"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"using OrgMaintenanceScripts\n\n# Format repos with failing CI and create PRs\nsuccesses, failures, pr_urls = format_org_repositories(\n    \"SciML\";\n    fork_user = \"sciml-bot\",\n    only_failing_ci = true,\n    test = false  # Tests will run in CI\n)","category":"page"},{"location":"formatting/#2.-Direct-Push-to-Master-(Use-with-Caution)","page":"Formatting Maintenance","title":"2. Direct Push to Master (Use with Caution)","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"For trusted automation that pushes directly to master after tests pass:","category":"page"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"# Only push if tests pass\nsuccesses, failures, _ = format_org_repositories(\n    \"SciML\";\n    push_to_master = true,\n    test = true,  # Must pass tests\n    create_pr = false\n)","category":"page"},{"location":"formatting/#3.-Single-Repository","page":"Formatting Maintenance","title":"3. Single Repository","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"Format a specific repository:","category":"page"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"success, message, pr_url = format_repository(\n    \"https://github.com/SciML/DifferentialEquations.jl.git\";\n    fork_user = \"myusername\"\n)","category":"page"},{"location":"formatting/#Prerequisites","page":"Formatting Maintenance","title":"Prerequisites","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"GitHub CLI: The gh command-line tool must be installed and authenticated\nGit: Git must be configured with appropriate credentials\nJulia: Julia 1.6 or higher\nFork Access: If creating PRs, you need fork access to the repositories","category":"page"},{"location":"formatting/#Notes","page":"Formatting Maintenance","title":"Notes","text":"","category":"section"},{"location":"formatting/","page":"Formatting Maintenance","title":"Formatting Maintenance","text":"The formatter uses the SciML style guide by default\nIf a repository doesn't have a .JuliaFormatter.toml file, one will be created\nTests are run with a 10-minute timeout by default\nRate limiting delays are included to avoid GitHub API limits\nAll operations are logged for audit purposes","category":"page"},{"location":"invalidation_analysis/#Invalidation-Analysis","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"The Invalidation Analysis functionality helps detect and analyze method invalidations that can significantly impact Julia package performance. This tool uses SnoopCompileCore to detect invalidations and provides detailed reports on the biggest performance problems.","category":"page"},{"location":"invalidation_analysis/#Overview","page":"Invalidation Analysis","title":"Overview","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Method invalidations occur when Julia needs to recompile previously compiled methods due to new method definitions. This can significantly slow down package loading and runtime performance. This module helps you:","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Detect invalidations in your packages\nIdentify the major invalidators causing the most problems\nGenerate comprehensive reports with actionable recommendations\nAnalyze entire organizations to find systemic issues","category":"page"},{"location":"invalidation_analysis/#Functions","page":"Invalidation Analysis","title":"Functions","text":"","category":"section"},{"location":"invalidation_analysis/#Single-Repository-Analysis","page":"Invalidation Analysis","title":"Single Repository Analysis","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"analyze_repo_invalidations(repo_path::String; test_script::String=\"\", output_file::String=\"\")","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Analyze invalidations in a single repository and generate a comprehensive report.","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Parameters:","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"repo_path: Path to the repository to analyze\ntest_script: Optional custom Julia code to run during analysis (defaults to loading the package and running tests)\noutput_file: Optional path to save detailed JSON report","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Returns: InvalidationReport object with analysis results","category":"page"},{"location":"invalidation_analysis/#Organization-wide-Analysis","page":"Invalidation Analysis","title":"Organization-wide Analysis","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"analyze_org_invalidations(org::String; auth_token::String=\"\", work_dir::String=mktempdir(), \n                         test_script::String=\"\", output_dir::String=\"\", max_repos::Int=0)","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Analyze invalidations across all repositories in a GitHub organization.","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Parameters:","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"org: GitHub organization name\nauth_token: GitHub authentication token for API access\nwork_dir: Working directory for cloning repositories\ntest_script: Custom test script to run for each repository\noutput_dir: Directory to save individual and summary reports\nmax_repos: Maximum number of repositories to analyze (0 = no limit)","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Returns: Dictionary mapping repository names to InvalidationReport objects","category":"page"},{"location":"invalidation_analysis/#Report-Generation","page":"Invalidation Analysis","title":"Report Generation","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"generate_invalidation_report(repo_path::String, test_script::String=\"\")","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Generate a detailed invalidation report for a repository without printing to console.","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Returns: InvalidationReport object","category":"page"},{"location":"invalidation_analysis/#Data-Structures","page":"Invalidation Analysis","title":"Data Structures","text":"","category":"section"},{"location":"invalidation_analysis/#InvalidationEntry","page":"Invalidation Analysis","title":"InvalidationEntry","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Represents a single invalidation with detailed information:","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"struct InvalidationEntry\n    method::String          # Method signature that was invalidated\n    file::String           # File where the method is defined\n    line::Int              # Line number in the file\n    package::String        # Package that owns the method\n    reason::String         # Description of why it's problematic\n    children_count::Int    # Number of methods invalidated by this one\n    depth::Int            # Depth in the invalidation tree\nend","category":"page"},{"location":"invalidation_analysis/#InvalidationReport","page":"Invalidation Analysis","title":"InvalidationReport","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Comprehensive report for a repository:","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"struct InvalidationReport\n    repo::String                           # Repository name\n    total_invalidations::Int              # Total number of invalidations\n    major_invalidators::Vector{InvalidationEntry}  # Top problematic invalidations\n    packages_affected::Vector{String}     # List of packages involved\n    analysis_time::DateTime              # When the analysis was performed\n    summary::String                      # Human-readable summary\n    recommendations::Vector{String}      # Actionable recommendations\nend","category":"page"},{"location":"invalidation_analysis/#Usage-Examples","page":"Invalidation Analysis","title":"Usage Examples","text":"","category":"section"},{"location":"invalidation_analysis/#Analyze-a-Single-Repository","page":"Invalidation Analysis","title":"Analyze a Single Repository","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"using OrgMaintenanceScripts\n\n# Basic analysis\nreport = analyze_repo_invalidations(\"/path/to/my/package\")\n\n# Analysis with custom test script and detailed output\ncustom_test = \"\"\"\n    using MyPackage\n    # Run specific operations that might cause invalidations\n    MyPackage.heavy_computation()\n    MyPackage.type_unstable_function([1, 2, 3])\n\"\"\"\n\nreport = analyze_repo_invalidations(\"/path/to/my/package\"; \n    test_script=custom_test,\n    output_file=\"invalidation_report.json\"\n)","category":"page"},{"location":"invalidation_analysis/#Analyze-an-Entire-Organization","page":"Invalidation Analysis","title":"Analyze an Entire Organization","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"# Set up GitHub authentication\ngithub_token = ENV[\"GITHUB_TOKEN\"]\n\n# Analyze all repositories in the SciML organization\nresults = analyze_org_invalidations(\"SciML\"; \n    auth_token=github_token,\n    output_dir=\"sciml_invalidation_reports\",\n    max_repos=10  # Limit to first 10 repos for testing\n)\n\n# Print summary statistics\ntotal_invalidations = sum(r.total_invalidations for r in values(results) if r.total_invalidations >= 0)\nprintln(\"Total invalidations across organization: $total_invalidations\")","category":"page"},{"location":"invalidation_analysis/#Custom-Analysis-Script","page":"Invalidation Analysis","title":"Custom Analysis Script","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"For specialized analysis, you can provide custom test scripts:","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"# Custom script for a web framework package\nweb_test_script = \"\"\"\n    using MyWebFramework\n    using HTTP\n    \n    # Test route handling (common source of invalidations)\n    app = MyWebFramework.App()\n    MyWebFramework.route!(app, \"/test\") do req\n        return \"Hello World\"\n    end\n    \n    # Test middleware chain\n    MyWebFramework.use!(app, MyWebFramework.CORSMiddleware())\n    MyWebFramework.use!(app, MyWebFramework.LoggingMiddleware())\n\"\"\"\n\nreport = analyze_repo_invalidations(\"/path/to/web/framework\"; \n    test_script=web_test_script\n)","category":"page"},{"location":"invalidation_analysis/#Understanding-the-Results","page":"Invalidation Analysis","title":"Understanding the Results","text":"","category":"section"},{"location":"invalidation_analysis/#Summary-Interpretations","page":"Invalidation Analysis","title":"Summary Interpretations","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"✅ 0 invalidations: Excellent! Your package is well-optimized\n✅ 1-9 invalidations: Good performance with minor issues\n⚠️ 10-49 invalidations: Moderate performance impact, room for improvement\n❌ 50+ invalidations: Significant performance problems requiring attention","category":"page"},{"location":"invalidation_analysis/#Major-Invalidators","page":"Invalidation Analysis","title":"Major Invalidators","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"The report identifies invalidations with the highest impact based on:","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Children Count: How many other methods this invalidation affects\nPackage: Which package is responsible (helps prioritize fixes)\nDepth: Position in the invalidation tree","category":"page"},{"location":"invalidation_analysis/#Common-Recommendations","page":"Invalidation Analysis","title":"Common Recommendations","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Type Stability: Ensure functions return consistent types\nMethod Definitions: Avoid redefining methods in package loading\nDependencies: Review packages that cause many invalidations\nSpecialization: Use @nospecialize for arguments that don't need specialization","category":"page"},{"location":"invalidation_analysis/#Organization-Reports","page":"Invalidation Analysis","title":"Organization Reports","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"When analyzing entire organizations, additional summary reports are generated:","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Markdown Summary: Overview of all repositories with rankings\nIndividual JSON Reports: Detailed data for each repository\nAction Items: Prioritized list of improvements","category":"page"},{"location":"invalidation_analysis/#Best-Practices","page":"Invalidation Analysis","title":"Best Practices","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Run Early: Analyze invalidations during development, not just before release\nMonitor Trends: Track invalidation counts over time\nFocus on Impact: Prioritize fixing invalidations with high children counts\nTest Thoroughly: Use realistic test scripts that exercise your package's main functionality\nOrganization Level: Run periodic organization-wide analyses to identify systemic issues","category":"page"},{"location":"invalidation_analysis/#Integration-with-CI/CD","page":"Invalidation Analysis","title":"Integration with CI/CD","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"You can integrate invalidation analysis into your CI pipeline:","category":"page"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"# In your CI script\nusing OrgMaintenanceScripts\n\nreport = analyze_repo_invalidations(\".\")\n\n# Fail CI if invalidations exceed threshold\nif report.total_invalidations > 20\n    println(\"❌ Too many invalidations: $(report.total_invalidations)\")\n    exit(1)\nend\n\nprintln(\"✅ Invalidation check passed: $(report.total_invalidations) invalidations\")","category":"page"},{"location":"invalidation_analysis/#Troubleshooting","page":"Invalidation Analysis","title":"Troubleshooting","text":"","category":"section"},{"location":"invalidation_analysis/#Common-Issues","page":"Invalidation Analysis","title":"Common Issues","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"SnoopCompileCore not found: Ensure SnoopCompileCore.jl is installed\nAnalysis fails: Check that the repository has a valid Project.toml and can be loaded\nPermission errors: Ensure you have read access to repositories and write access to output directories\nMemory issues: For large organizations, use max_repos to limit analysis scope","category":"page"},{"location":"invalidation_analysis/#Performance-Considerations","page":"Invalidation Analysis","title":"Performance Considerations","text":"","category":"section"},{"location":"invalidation_analysis/","page":"Invalidation Analysis","title":"Invalidation Analysis","text":"Analysis runs in separate Julia processes to avoid contamination\nLarge organizations may take significant time to analyze\nConsider running analyses on powerful machines for better performance\nUse max_repos parameter to test on subsets first","category":"page"},{"location":"min_version_fixing/#Minimum-Version-Fixing","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"","category":"section"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"The OrgMaintenanceScripts.jl package provides tools to automatically fix minimum version compatibility bounds for Julia packages. This functionality helps ensure that packages pass the downgrade CI tests by intelligently updating outdated minimum version specifications.","category":"page"},{"location":"min_version_fixing/#Overview","page":"Minimum Version Fixing","title":"Overview","text":"","category":"section"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"The minimum version fixer:","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Uses Stefan Karpinski's Resolver.jl to test if minimum versions can be resolved\nIdentifies packages with problematic minimum versions through resolver errors\nIntelligently bumps versions using multiple strategies\nCreates pull requests with the fixes automatically","category":"page"},{"location":"min_version_fixing/#Functions","page":"Minimum Version Fixing","title":"Functions","text":"","category":"section"},{"location":"min_version_fixing/#fix_package_min_versions","page":"Minimum Version Fixing","title":"fix_package_min_versions","text":"","category":"section"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Fix minimum versions for a package that's already cloned locally.","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"fix_package_min_versions(repo_path::String; \n                        max_iterations::Int=10,\n                        work_dir::String=mktempdir(),\n                        julia_version::String=\"1.10\")","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Parameters:","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"repo_path: Path to the cloned repository\nmax_iterations: Maximum number of fix iterations (default: 10)\nwork_dir: Working directory for temporary files\njulia_version: Julia version for compatibility testing (default: \"1.10\")","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Returns: (success::Bool, updates::Dict{String,String})","category":"page"},{"location":"min_version_fixing/#fix_repo_min_versions","page":"Minimum Version Fixing","title":"fix_repo_min_versions","text":"","category":"section"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Clone a repository, fix its minimum versions, and optionally create a PR.","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"fix_repo_min_versions(repo_name::String;\n                     work_dir::String=mktempdir(),\n                     max_iterations::Int=10,\n                     create_pr::Bool=true,\n                     julia_version::String=\"1.10\")","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Parameters:","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"repo_name: GitHub repository name (e.g., \"SciML/OrdinaryDiffEq.jl\")\nwork_dir: Working directory for cloning and temporary files\nmax_iterations: Maximum number of fix iterations\ncreate_pr: Whether to create a pull request (default: true)\njulia_version: Julia version for compatibility testing","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Returns: success::Bool","category":"page"},{"location":"min_version_fixing/#fix_org_min_versions","page":"Minimum Version Fixing","title":"fix_org_min_versions","text":"","category":"section"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Fix minimum versions for all Julia packages in a GitHub organization.","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"fix_org_min_versions(org_name::String;\n                    work_dir::String=mktempdir(),\n                    max_iterations::Int=10,\n                    create_prs::Bool=true,\n                    skip_repos::Vector{String}=String[],\n                    only_repos::Union{Nothing,Vector{String}}=nothing,\n                    julia_version::String=\"1.10\")","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Parameters:","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"org_name: GitHub organization name (e.g., \"SciML\")\nwork_dir: Working directory\nmax_iterations: Maximum iterations per repository\ncreate_prs: Whether to create pull requests\nskip_repos: Repository names to skip\nonly_repos: If specified, only process these repositories\njulia_version: Julia version for compatibility testing","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Returns: results::Dict{String,Bool} mapping repository names to success status","category":"page"},{"location":"min_version_fixing/#Usage-Examples","page":"Minimum Version Fixing","title":"Usage Examples","text":"","category":"section"},{"location":"min_version_fixing/#Fix-a-Single-Package","page":"Minimum Version Fixing","title":"Fix a Single Package","text":"","category":"section"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"using OrgMaintenanceScripts\n\n# Fix a repository by name (clones automatically)\nfix_repo_min_versions(\"SciML/OrdinaryDiffEq.jl\")\n\n# Fix without creating a PR\nfix_repo_min_versions(\"SciML/DiffEqBase.jl\"; create_pr=false)\n\n# Fix an already cloned repository\nsuccess, updates = fix_package_min_versions(\"/path/to/cloned/repo\")","category":"page"},{"location":"min_version_fixing/#Fix-an-Entire-Organization","page":"Minimum Version Fixing","title":"Fix an Entire Organization","text":"","category":"section"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"# Fix all Julia packages in the SciML organization\nresults = fix_org_min_versions(\"SciML\")\n\n# Skip certain repositories\nresults = fix_org_min_versions(\"SciML\"; skip_repos=[\"SciMLDocs\", \"SciMLBenchmarks.jl\"])\n\n# Only process specific repositories\nresults = fix_org_min_versions(\"SciML\"; only_repos=[\"OrdinaryDiffEq.jl\", \"DiffEqBase.jl\"])\n\n# Don't create PRs (useful for testing)\nresults = fix_org_min_versions(\"SciML\"; create_prs=false)","category":"page"},{"location":"min_version_fixing/#Version-Bumping-Strategy","page":"Minimum Version Fixing","title":"Version Bumping Strategy","text":"","category":"section"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"The tool uses multiple strategies to determine appropriate minimum versions:","category":"page"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Registry Lookup: Queries the General registry for the latest compatible version\nConservative Bumping:\nFor 0.x packages: Uses the latest 0.x version\nFor stable packages (≥1.0): Uses major.0.0\nPreserves existing upper bounds in all compat entries\nFallback Strategy: If registry lookup fails, conservatively bumps the current version","category":"page"},{"location":"min_version_fixing/#Requirements","page":"Minimum Version Fixing","title":"Requirements","text":"","category":"section"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Julia 1.6+\nGit\nGitHub CLI (gh) for automatic PR creation\nAuthenticated with GitHub (gh auth login)","category":"page"},{"location":"min_version_fixing/#How-It-Works","page":"Minimum Version Fixing","title":"How It Works","text":"","category":"section"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"Clone Repository: Clones the target repository (if needed)\nCreate Branch: Creates a feature branch for the fixes\nTest Resolution: Uses Resolver.jl with --min=@alldeps to test if minimum versions resolve\nIdentify Issues: Parses resolver errors to find problematic packages\nApply Fixes: Intelligently bumps failing minimum versions\nIterate: Repeats until all packages resolve\nCreate PR: Commits changes and creates a detailed pull request","category":"page"},{"location":"min_version_fixing/#Example-Output","page":"Minimum Version Fixing","title":"Example Output","text":"","category":"section"},{"location":"min_version_fixing/","page":"Minimum Version Fixing","title":"Minimum Version Fixing","text":"[ Info: Fixing minimum versions for OrdinaryDiffEq\n[ Info: Iteration 1/10\n[ Info: Resolution failed, analyzing...\n[ Info: Found problematic packages: RecursiveArrayTools, StaticArrays\n[ Info: Updated RecursiveArrayTools: 2.0 → 3.0\n[ Info: Updated StaticArrays: 0.12 → 1.0\n[ Info: Iteration 2/10\n[ Info: ✓ Minimum versions resolved successfully!\n[ Info: Creating pull request...\n[ Info: ✓ Pull request created successfully!","category":"page"},{"location":"import_timing_analysis/#Import-Timing-Analysis","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"The Import Timing Analysis functionality helps identify and analyze package import latency using Julia's built-in @time_imports macro. This tool provides detailed insights into which dependencies are causing slow package loading times and offers actionable recommendations for optimization.","category":"page"},{"location":"import_timing_analysis/#Overview","page":"Import Timing Analysis","title":"Overview","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Package import time significantly affects user experience, especially for interactive Julia usage. This module helps you:","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Measure import timing for individual packages and their dependencies\nIdentify the major contributors to slow loading times\nGenerate comprehensive reports with optimization recommendations\nAnalyze entire organizations to find systemic performance issues\nTrack import time regressions over time","category":"page"},{"location":"import_timing_analysis/#Functions","page":"Import Timing Analysis","title":"Functions","text":"","category":"section"},{"location":"import_timing_analysis/#Single-Repository-Analysis","page":"Import Timing Analysis","title":"Single Repository Analysis","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"analyze_repo_import_timing(repo_path::String; package_name::String=\"\", output_file::String=\"\")","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Analyze import timing for a single repository and generate a comprehensive report.","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Parameters:","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"repo_path: Path to the repository to analyze\npackage_name: Package name to analyze (auto-detected from Project.toml if not provided)\noutput_file: Optional path to save detailed JSON report","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Returns: ImportTimingReport object with analysis results","category":"page"},{"location":"import_timing_analysis/#Organization-wide-Analysis","page":"Import Timing Analysis","title":"Organization-wide Analysis","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"analyze_org_import_timing(org::String; auth_token::String=\"\", work_dir::String=mktempdir(), \n                         output_dir::String=\"\", max_repos::Int=0)","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Analyze import timing across all repositories in a GitHub organization.","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Parameters:","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"org: GitHub organization name\nauth_token: GitHub authentication token for API access\nwork_dir: Working directory for cloning repositories\noutput_dir: Directory to save individual and summary reports\nmax_repos: Maximum number of repositories to analyze (0 = no limit)","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Returns: Dictionary mapping repository names to ImportTimingReport objects","category":"page"},{"location":"import_timing_analysis/#Report-Generation","page":"Import Timing Analysis","title":"Report Generation","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"generate_import_timing_report(repo_path::String, package_name::String=\"\")","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Generate a detailed import timing report without printing to console.","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Returns: ImportTimingReport object","category":"page"},{"location":"import_timing_analysis/#Data-Structures","page":"Import Timing Analysis","title":"Data Structures","text":"","category":"section"},{"location":"import_timing_analysis/#ImportTiming","page":"Import Timing Analysis","title":"ImportTiming","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Represents timing information for a single package:","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"struct ImportTiming\n    package_name::String        # Name of the package\n    total_time::Float64        # Total import time in seconds\n    precompile_time::Float64   # Time spent in precompilation\n    load_time::Float64         # Time spent loading (excluding precompilation)\n    dependencies::Vector{String}  # Direct dependencies\n    dep_count::Int            # Number of dependencies\n    is_local::Bool            # Whether this is the local package being analyzed\nend","category":"page"},{"location":"import_timing_analysis/#ImportTimingReport","page":"Import Timing Analysis","title":"ImportTimingReport","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Comprehensive report for a repository:","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"struct ImportTimingReport\n    repo::String                    # Repository name\n    package_name::String           # Package being analyzed\n    total_import_time::Float64     # Total time to import the package\n    major_contributors::Vector{ImportTiming}  # Packages contributing most to import time\n    dependency_chain::Vector{String}  # Order in which dependencies are loaded\n    analysis_time::DateTime        # When the analysis was performed\n    summary::String               # Human-readable summary\n    recommendations::Vector{String}  # Actionable recommendations\n    raw_output::String            # Raw @time_imports output for debugging\nend","category":"page"},{"location":"import_timing_analysis/#Usage-Examples","page":"Import Timing Analysis","title":"Usage Examples","text":"","category":"section"},{"location":"import_timing_analysis/#Analyze-a-Single-Repository","page":"Import Timing Analysis","title":"Analyze a Single Repository","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"using OrgMaintenanceScripts\n\n# Basic analysis (auto-detects package name)\nreport = analyze_repo_import_timing(\"/path/to/my/package\")\n\n# Analysis with specific package name and detailed output\nreport = analyze_repo_import_timing(\"/path/to/my/package\"; \n    package_name=\"MyPackage\",\n    output_file=\"import_timing_report.json\"\n)\n\n# View the results\nprintln(\"Total import time: $(report.total_import_time) seconds\")\nfor contributor in report.major_contributors[1:5]  # Top 5\n    println(\"$(contributor.package_name): $(contributor.total_time)s\")\nend","category":"page"},{"location":"import_timing_analysis/#Analyze-an-Entire-Organization","page":"Import Timing Analysis","title":"Analyze an Entire Organization","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"# Set up GitHub authentication\ngithub_token = ENV[\"GITHUB_TOKEN\"]\n\n# Analyze all repositories in the SciML organization\nresults = analyze_org_import_timing(\"SciML\"; \n    auth_token=github_token,\n    output_dir=\"import_timing_reports\",\n    max_repos=10  # Limit to first 10 repos for testing\n)\n\n# Find the slowest loading packages\nslowest = sort([(name, r.total_import_time) for (name, r) in results], by=x->x[2], rev=true)\nprintln(\"Slowest packages:\")\nfor (name, time) in slowest[1:5]\n    println(\"$name: $(round(time, digits=2))s\")\nend","category":"page"},{"location":"import_timing_analysis/#Custom-Analysis-for-Specific-Scenarios","page":"Import Timing Analysis","title":"Custom Analysis for Specific Scenarios","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"# Analyze a web framework for startup time optimization\nweb_report = analyze_repo_import_timing(\"/path/to/web/framework\")\n\n# Focus on dependencies taking >0.5 seconds\nslow_deps = filter(t -> t.total_time > 0.5 && !t.is_local, web_report.major_contributors)\nprintln(\"Dependencies to optimize:\")\nfor dep in slow_deps\n    println(\"- $(dep.package_name): $(round(dep.total_time, digits=2))s\")\n    if dep.precompile_time > dep.load_time\n        println(\"  → High precompilation time, consider PackageCompiler.jl\")\n    end\nend","category":"page"},{"location":"import_timing_analysis/#Understanding-the-Results","page":"Import Timing Analysis","title":"Understanding the Results","text":"","category":"section"},{"location":"import_timing_analysis/#Import-Time-Classifications","page":"Import Timing Analysis","title":"Import Time Classifications","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"✅ < 1 second: Excellent user experience\n✅ 1-3 seconds: Good performance, acceptable for most use cases\n⚠️ 3-10 seconds: Moderate delay, room for improvement\n❌ > 10 seconds: Poor user experience, immediate optimization needed","category":"page"},{"location":"import_timing_analysis/#Major-Contributors-Analysis","page":"Import Timing Analysis","title":"Major Contributors Analysis","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"The analysis identifies packages that contribute significantly to import time:","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Total Time: Overall impact on import performance\nPrecompile vs Load Time: Helps identify optimization strategies\nDependency Chain: Shows the order dependencies are loaded\nLocal vs External: Distinguishes your package from dependencies","category":"page"},{"location":"import_timing_analysis/#Common-Optimization-Strategies","page":"Import Timing Analysis","title":"Common Optimization Strategies","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Based on timing patterns, the tool suggests:","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"High Precompilation Time: Use PackageCompiler.jl for system images\nSlow Dependencies: Consider alternatives or lazy loading\nMany Dependencies: Reduce dependency count if possible\nLarge Packages: Use package extensions or conditional loading","category":"page"},{"location":"import_timing_analysis/#Organization-Reports","page":"Import Timing Analysis","title":"Organization Reports","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"When analyzing entire organizations, additional insights are provided:","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Average Import Time: Organization-wide performance metric\nSlowest Packages: Ranking of packages by import time\nProblematic Dependencies: Dependencies that slow down multiple packages\nPerformance Distribution: Understanding of organization-wide patterns","category":"page"},{"location":"import_timing_analysis/#Best-Practices","page":"Import Timing Analysis","title":"Best Practices","text":"","category":"section"},{"location":"import_timing_analysis/#Development-Workflow","page":"Import Timing Analysis","title":"Development Workflow","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Baseline Measurement: Measure import time early in development\nDependency Review: Carefully evaluate new dependencies\nRegular Monitoring: Track import time as part of CI/CD\nUser Testing: Consider import time in user experience planning","category":"page"},{"location":"import_timing_analysis/#Optimization-Techniques","page":"Import Timing Analysis","title":"Optimization Techniques","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Lazy Loading: Use Requires.jl for optional dependencies\nPackage Extensions: Use Julia 1.9+ package extensions for conditional features\nPrecompilation: Optimize precompile statements\nSystem Images: Use PackageCompiler.jl for deployment scenarios","category":"page"},{"location":"import_timing_analysis/#CI/CD-Integration","page":"Import Timing Analysis","title":"CI/CD Integration","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"# Example CI script for import time monitoring\nusing OrgMaintenanceScripts\n\nreport = analyze_repo_import_timing(\".\")\n\n# Set thresholds based on package type\nmax_import_time = 5.0  # seconds\nwarning_threshold = 2.0\n\nif report.total_import_time > max_import_time\n    println(\"❌ FAILED: Import time too slow ($(report.total_import_time)s > $(max_import_time)s)\")\n    exit(1)\nelseif report.total_import_time > warning_threshold\n    println(\"⚠️ WARNING: Import time increasing ($(report.total_import_time)s)\")\nelse\n    println(\"✅ PASSED: Good import performance ($(report.total_import_time)s)\")\nend","category":"page"},{"location":"import_timing_analysis/#Advanced-Usage","page":"Import Timing Analysis","title":"Advanced Usage","text":"","category":"section"},{"location":"import_timing_analysis/#Custom-Timing-Analysis","page":"Import Timing Analysis","title":"Custom Timing Analysis","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"For specialized analysis needs:","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"# Generate report without console output\nreport = generate_import_timing_report(\"/path/to/package\")\n\n# Access raw @time_imports output for custom parsing\nraw_output = report.raw_output\nprintln(\"Raw timing data:\")\nprintln(raw_output)\n\n# Analyze specific patterns\nprecompile_heavy = filter(t -> t.precompile_time > t.load_time, report.major_contributors)\nload_heavy = filter(t -> t.load_time > t.precompile_time, report.major_contributors)","category":"page"},{"location":"import_timing_analysis/#Trend-Analysis","page":"Import Timing Analysis","title":"Trend Analysis","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Combine with version control for regression detection:","category":"page"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"# Compare import times across git commits\nfunction analyze_import_trend(repo_path, commits)\n    results = []\n    for commit in commits\n        run(`git -C $repo_path checkout $commit`)\n        report = generate_import_timing_report(repo_path)\n        push!(results, (commit, report.total_import_time))\n    end\n    return results\nend","category":"page"},{"location":"import_timing_analysis/#Troubleshooting","page":"Import Timing Analysis","title":"Troubleshooting","text":"","category":"section"},{"location":"import_timing_analysis/#Common-Issues","page":"Import Timing Analysis","title":"Common Issues","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Analysis Fails: Ensure the package can be imported successfully\nMissing Dependencies: Run Pkg.instantiate() in the target repository\nPermission Errors: Ensure read access to repositories\nTimeout Issues: Some packages may take very long to import","category":"page"},{"location":"import_timing_analysis/#Performance-Considerations","page":"Import Timing Analysis","title":"Performance Considerations","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Analysis runs in separate Julia processes to ensure clean timing\nLarge organizations may take significant time to analyze\nConsider using max_repos parameter for initial testing\nNetwork speed affects repository cloning time","category":"page"},{"location":"import_timing_analysis/#Interpreting-Results","page":"Import Timing Analysis","title":"Interpreting Results","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"Precompilation Time: Usually one-time cost, optimizable with system images\nLoad Time: Runtime cost for every import, focus optimization here\nDependency Chain: Earlier dependencies affect later ones\nLocal vs External: You can only directly optimize local package timing","category":"page"},{"location":"import_timing_analysis/#Integration-Examples","page":"Import Timing Analysis","title":"Integration Examples","text":"","category":"section"},{"location":"import_timing_analysis/#GitHub-Actions","page":"Import Timing Analysis","title":"GitHub Actions","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"name: Import Time Check\non: [push, pull_request]\njobs:\n  import-timing:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: julia-actions/setup-julia@v1\n      - name: Analyze Import Timing\n        run: |\n          julia -e '\n            using Pkg; Pkg.add(\"OrgMaintenanceScripts\")\n            using OrgMaintenanceScripts\n            report = analyze_repo_import_timing(\".\")\n            if report.total_import_time > 5.0\n              error(\"Import time too slow: $(report.total_import_time)s\")\n            end\n          '","category":"page"},{"location":"import_timing_analysis/#Organization-Monitoring","page":"Import Timing Analysis","title":"Organization Monitoring","text":"","category":"section"},{"location":"import_timing_analysis/","page":"Import Timing Analysis","title":"Import Timing Analysis","text":"# Weekly organization analysis\nfunction weekly_import_analysis(org)\n    results = analyze_org_import_timing(org; \n        auth_token=ENV[\"GITHUB_TOKEN\"],\n        output_dir=\"weekly_reports/$(today())\"\n    )\n    \n    # Generate alerts for regressions\n    slow_packages = [name for (name, report) in results if report.total_import_time > 10.0]\n    \n    if !isempty(slow_packages)\n        println(\"⚠️ Slow packages detected:\")\n        for pkg in slow_packages\n            println(\"- $pkg: $(results[pkg].total_import_time)s\")\n        end\n    end\n    \n    return results\nend","category":"page"},{"location":"version_bumping/#Version-Bumping-and-Registration","page":"Version Bumping","title":"Version Bumping and Registration","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"The OrgMaintenanceScripts.jl package provides tools for automatically bumping minor versions and registering Julia packages. This functionality helps maintain consistent versioning across packages and simplifies the release process.","category":"page"},{"location":"version_bumping/#Overview","page":"Version Bumping","title":"Overview","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"The version bumping and registration tools:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Automatically increment minor version numbers in Project.toml files\nHandle main packages and subpackages in lib/ directories\nCreate git commits for version changes\nRegister packages to Julia registries (placeholder functionality)\nProcess entire GitHub organizations at once","category":"page"},{"location":"version_bumping/#Functions","page":"Version Bumping","title":"Functions","text":"","category":"section"},{"location":"version_bumping/#bump_minor_version","page":"Version Bumping","title":"bump_minor_version","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Bump the minor version of a semantic version string.","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"bump_minor_version(version_str::String) -> String","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Parameters:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"version_str: A semantic version string (e.g., \"1.2.3\")","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Returns: New version string with incremented minor version (e.g., \"1.3.0\")","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Example:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"new_version = bump_minor_version(\"1.2.3\")  # Returns \"1.3.0\"\nnew_version = bump_minor_version(\"0.5.0\")  # Returns \"0.6.0\"","category":"page"},{"location":"version_bumping/#update_project_version","page":"Version Bumping","title":"update_project_version","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Update the version in a Project.toml file by bumping the minor version.","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"update_project_version(project_path::String)","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Parameters:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"project_path: Path to the Project.toml file","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Returns: Tuple (old_version, new_version) or nothing if no version field exists","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Example:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"result = update_project_version(\"path/to/Project.toml\")\nif !isnothing(result)\n    old_ver, new_ver = result\n    println(\"Updated: $old_ver → $new_ver\")\nend","category":"page"},{"location":"version_bumping/#register_package","page":"Version Bumping","title":"register_package","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Register a Julia package to the specified registry.","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"register_package(package_dir::String; registry_url=\"https://github.com/JuliaRegistries/General\")","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Parameters:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"package_dir: Directory containing the package to register\nregistry_url: URL of the target registry (default: General registry)","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Returns: true on success","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"note: Note\nThis is currently a placeholder function. In practice, it would use LocalRegistry.jl or similar tools for actual registration.","category":"page"},{"location":"version_bumping/#bump_and_register_repo","page":"Version Bumping","title":"bump_and_register_repo","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Bump minor versions and register all packages in a repository.","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"bump_and_register_repo(repo_path::String; registry_url=\"https://github.com/JuliaRegistries/General\")","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Parameters:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"repo_path: Path to the repository\nregistry_url: URL of the target registry","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Returns: Named tuple (registered=String[], failed=String[])","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"This function:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Updates the main Project.toml (if exists)\nUpdates all lib/*/Project.toml files\nAttempts to register each package\nCommits version changes to git","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Example:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"result = bump_and_register_repo(\"/path/to/MyPackage.jl\")\nprintln(\"Successfully registered: \", result.registered)\nprintln(\"Failed to register: \", result.failed)","category":"page"},{"location":"version_bumping/#get_org_repos","page":"Version Bumping","title":"get_org_repos","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Get all repositories for a GitHub organization.","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"get_org_repos(org::String; auth_token::String=\"\")","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Parameters:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"org: GitHub organization name\nauth_token: GitHub authentication token (optional but recommended)","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Returns: Vector of repository full names (e.g., \"SciML/OrdinaryDiffEq.jl\")","category":"page"},{"location":"version_bumping/#bump_and_register_org","page":"Version Bumping","title":"bump_and_register_org","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Bump minor versions and register all packages in all repositories of a GitHub organization.","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"bump_and_register_org(org::String; \n                     registry_url=\"https://github.com/JuliaRegistries/General\",\n                     auth_token::String=\"\",\n                     work_dir::String=mktempdir())","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Parameters:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"org: GitHub organization name\nregistry_url: URL of the target registry\nauth_token: GitHub authentication token\nwork_dir: Working directory for cloning repositories","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Returns: Dictionary mapping repository names to results","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Example:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"results = bump_and_register_org(\"SciML\"; auth_token=ENV[\"GITHUB_TOKEN\"])\n\nfor (repo, result) in results\n    println(\"$repo:\")\n    println(\"  Registered: \", result.registered)\n    println(\"  Failed: \", result.failed)\nend","category":"page"},{"location":"version_bumping/#Usage-Examples","page":"Version Bumping","title":"Usage Examples","text":"","category":"section"},{"location":"version_bumping/#Bump-Version-for-a-Single-Package","page":"Version Bumping","title":"Bump Version for a Single Package","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"using OrgMaintenanceScripts\n\n# Update version in Project.toml\nold_ver, new_ver = update_project_version(\"MyPackage/Project.toml\")\nprintln(\"Version bumped: $old_ver → $new_ver\")","category":"page"},{"location":"version_bumping/#Process-a-Repository-with-Subpackages","page":"Version Bumping","title":"Process a Repository with Subpackages","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"# Bump versions and register all packages in a repository\nresult = bump_and_register_repo(\"/path/to/ComplexPackage.jl\")\n\nprintln(\"Main package and $(length(result.registered)-1) subpackages processed\")","category":"page"},{"location":"version_bumping/#Process-an-Entire-Organization","page":"Version Bumping","title":"Process an Entire Organization","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"# Set up authentication\nauth_token = ENV[\"GITHUB_TOKEN\"]\n\n# Process all repositories in the SciML organization\nresults = bump_and_register_org(\"SciML\"; auth_token=auth_token)\n\n# Generate summary report\ntotal_registered = sum(length(r.registered) for r in values(results))\ntotal_failed = sum(length(r.failed) for r in values(results))\n\nprintln(\"Organization Summary:\")\nprintln(\"  Total packages registered: $total_registered\")\nprintln(\"  Total failures: $total_failed\")","category":"page"},{"location":"version_bumping/#Workflow-Integration","page":"Version Bumping","title":"Workflow Integration","text":"","category":"section"},{"location":"version_bumping/#Automated-Release-Process","page":"Version Bumping","title":"Automated Release Process","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Version Bumping: Automatically increment minor versions\nGit Commit: Create commits with descriptive messages\nRegistration: Register to Julia registries\nPush Changes: Push version bumps to remote","category":"page"},{"location":"version_bumping/#CI/CD-Integration","page":"Version Bumping","title":"CI/CD Integration","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"The tools can be integrated into CI/CD pipelines:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"# Example GitHub Action\n- name: Bump and Register\n  run: |\n    julia -e 'using OrgMaintenanceScripts; \n             bump_and_register_repo(\".\")'","category":"page"},{"location":"version_bumping/#Error-Handling","page":"Version Bumping","title":"Error Handling","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"The functions include comprehensive error handling:","category":"page"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Missing Project.toml files generate warnings\nRegistration failures are captured and reported\nGit operations are wrapped in try-catch blocks\nEach repository in organization processing is isolated","category":"page"},{"location":"version_bumping/#Best-Practices","page":"Version Bumping","title":"Best Practices","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Authentication: Always use GitHub tokens for organization operations\nTesting: Test version bumping on a single package first\nBackup: The tools create git commits, ensuring changes can be reverted\nReview: Check the results before pushing to remote repositories","category":"page"},{"location":"version_bumping/#Limitations","page":"Version Bumping","title":"Limitations","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Currently only bumps minor versions (not major or patch)\nRegistration is a placeholder (requires LocalRegistry.jl integration)\nAssumes semantic versioning (MAJOR.MINOR.PATCH)\nRequires git to be configured with appropriate credentials","category":"page"},{"location":"version_bumping/#API-Summary","page":"Version Bumping","title":"API Summary","text":"","category":"section"},{"location":"version_bumping/","page":"Version Bumping","title":"Version Bumping","text":"Function Description\nbump_minor_version(version_str) Increment minor version number\nupdate_project_version(project_path) Update version in Project.toml\nregister_package(package_dir; registry_url) Register package (placeholder)\nbump_and_register_repo(repo_path; registry_url) Process entire repository\nget_org_repos(org; auth_token) List organization repositories\nbump_and_register_org(org; kwargs...) Process entire organization","category":"page"},{"location":"explicit_imports_fixing/#Explicit-Imports-Fixing","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"The explicit imports fixer uses ExplicitImports.jl to automatically detect and fix import issues in Julia packages. It iteratively runs checks and applies fixes until all explicit import best practices are satisfied.","category":"page"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"ExplicitImports.jl is included as a direct dependency of OrgMaintenanceScripts, so no additional setup is required.","category":"page"},{"location":"explicit_imports_fixing/#Features","page":"Explicit Imports Fixing","title":"Features","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"Automatic Detection: Uses ExplicitImports.jl to find implicit imports and unused explicit imports\nIterative Fixing: Repeatedly applies fixes and re-checks until all issues are resolved\nSafe Modifications: Verifies the package still loads after each round of fixes\nPull Request Creation: Automatically creates PRs with detailed explanations of changes\nOrganization-wide Processing: Can process entire GitHub organizations","category":"page"},{"location":"explicit_imports_fixing/#Usage","page":"Explicit Imports Fixing","title":"Usage","text":"","category":"section"},{"location":"explicit_imports_fixing/#Fix-a-Single-Package","page":"Explicit Imports Fixing","title":"Fix a Single Package","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"using OrgMaintenanceScripts\n\n# Fix explicit imports in a local package\nsuccess, iterations, report = fix_explicit_imports(\"/path/to/MyPackage.jl\")\n\nif success\n    println(\"✓ All explicit import checks pass after $iterations iterations!\")\nelse\n    println(\"Some issues remain after $iterations iterations\")\n    println(report)\nend","category":"page"},{"location":"explicit_imports_fixing/#Fix-a-Repository","page":"Explicit Imports Fixing","title":"Fix a Repository","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"# Clone, fix, and create a PR for a repository\nsuccess = fix_repo_explicit_imports(\"MyOrg/MyPackage.jl\";\n    create_pr = true,\n    max_iterations = 10\n)","category":"page"},{"location":"explicit_imports_fixing/#Fix-an-Entire-Organization","page":"Explicit Imports Fixing","title":"Fix an Entire Organization","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"# Process all Julia packages in an organization\nresults = fix_org_explicit_imports(\"MyOrg\";\n    create_prs = true,\n    skip_repos = [\"DeprecatedPackage.jl\"],\n    only_repos = nothing  # Process all repos\n)\n\n# Summary of results\nfor (repo, success) in results\n    println(\"$repo: \", success ? \"✓ Fixed\" : \"✗ Failed/No changes\")\nend","category":"page"},{"location":"explicit_imports_fixing/#How-It-Works","page":"Explicit Imports Fixing","title":"How It Works","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"The fixer follows this iterative process:","category":"page"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"Run ExplicitImports.jl checks on the package\nParse the output to identify specific issues:\nMissing explicit imports (e.g., using println without using Base: println)\nUnused explicit imports (e.g., using Base: push! when push! is never used)\nApply fixes to the source files:\nAdd missing imports at appropriate locations\nRemove unused imports while preserving other imports\nVerify the package still loads correctly\nRepeat until all checks pass or maximum iterations reached","category":"page"},{"location":"explicit_imports_fixing/#Example-Fixes","page":"Explicit Imports Fixing","title":"Example Fixes","text":"","category":"section"},{"location":"explicit_imports_fixing/#Missing-Import","page":"Explicit Imports Fixing","title":"Missing Import","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"Before:","category":"page"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"module MyModule\n\nfunction greet(name)\n    println(\"Hello, $name!\")  # println used implicitly\nend\n\nend","category":"page"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"After:","category":"page"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"module MyModule\n\nusing Base: println\n\nfunction greet(name)\n    println(\"Hello, $name!\")\nend\n\nend","category":"page"},{"location":"explicit_imports_fixing/#Unused-Import","page":"Explicit Imports Fixing","title":"Unused Import","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"Before:","category":"page"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"module MyModule\n\nusing Base: println, push!, filter  # push! is never used\n\nfunction process(items)\n    filtered = filter(x -> x > 0, items)\n    println(\"Processed $(length(filtered)) items\")\nend\n\nend","category":"page"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"After:","category":"page"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"module MyModule\n\nusing Base: println, filter\n\nfunction process(items)\n    filtered = filter(x -> x > 0, items)\n    println(\"Processed $(length(filtered)) items\")\nend\n\nend","category":"page"},{"location":"explicit_imports_fixing/#Options","page":"Explicit Imports Fixing","title":"Options","text":"","category":"section"},{"location":"explicit_imports_fixing/#fix_explicit_imports","page":"Explicit Imports Fixing","title":"fix_explicit_imports","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"package_path: Path to the package directory\nmax_iterations: Maximum number of fix/check cycles (default: 10)\nverbose: Show detailed output during processing (default: true)","category":"page"},{"location":"explicit_imports_fixing/#fix_repo_explicit_imports","page":"Explicit Imports Fixing","title":"fix_repo_explicit_imports","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"repo_name: GitHub repository name (e.g., \"MyOrg/Package.jl\")\nwork_dir: Temporary directory for cloning (default: mktempdir())\nmax_iterations: Maximum number of fix/check cycles (default: 10)\ncreate_pr: Whether to create a pull request (default: true)\nverbose: Show detailed output (default: true)","category":"page"},{"location":"explicit_imports_fixing/#fix_org_explicit_imports","page":"Explicit Imports Fixing","title":"fix_org_explicit_imports","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"org_name: GitHub organization name\nwork_dir: Temporary directory for processing (default: mktempdir())\nmax_iterations: Maximum iterations per package (default: 10)\ncreate_prs: Whether to create pull requests (default: true)\nskip_repos: Array of repository names to skip\nonly_repos: Process only these repositories (default: all)\nverbose: Show detailed output (default: true)","category":"page"},{"location":"explicit_imports_fixing/#Benefits","page":"Explicit Imports Fixing","title":"Benefits","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"Using explicit imports provides several benefits:","category":"page"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"Clarity: Makes dependencies explicit and clear\nPerformance: Can improve load times by avoiding unnecessary imports\nMaintainability: Easier to track what external functions are used\nStability: Reduces risk of name conflicts when packages export new names\nStatic Analysis: Better compatibility with tools that analyze code","category":"page"},{"location":"explicit_imports_fixing/#Limitations","page":"Explicit Imports Fixing","title":"Limitations","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"Requires ExplicitImports.jl to be installable in the package environment\nMay not catch all edge cases that require manual review\nSome packages may have legitimate reasons for implicit imports\nComplex macro usage might not be handled perfectly","category":"page"},{"location":"explicit_imports_fixing/#Best-Practices","page":"Explicit Imports Fixing","title":"Best Practices","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"Review Changes: Always review the automated changes before merging\nRun Tests: Ensure your test suite passes after fixes\nIncremental Adoption: For large packages, consider fixing one module at a time\nDocument Exceptions: If you need implicit imports, document why","category":"page"},{"location":"explicit_imports_fixing/#Troubleshooting","page":"Explicit Imports Fixing","title":"Troubleshooting","text":"","category":"section"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"If the fixer encounters issues:","category":"page"},{"location":"explicit_imports_fixing/","page":"Explicit Imports Fixing","title":"Explicit Imports Fixing","text":"Check Package Loads: Ensure your package loads without the fixes\nUpdate Dependencies: Make sure all dependencies are up to date\nManual Review: Some complex cases may need manual intervention\nReport Issues: File issues for packages that can't be automatically fixed","category":"page"},{"location":"#OrgMaintenanceScripts.jl","page":"Home","title":"OrgMaintenanceScripts.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OrgMaintenanceScripts.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides maintenance scripts for SciML organization repositories, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Code Formatting: Automated formatting with JuliaFormatter across entire organizations\nVersion Bumping: Automatically bump minor versions in Project.toml files\nPackage Registration: Register packages to Julia registries\nMinimum Version Fixing: Fix minimum version compatibility bounds to pass downgrade CI tests\nCompat Bumping: Automatically update package compatibility bounds for dependencies\nVersion Check Finding: Find outdated VERSION checks that can be removed\nInvalidation Analysis: Use SnoopCompileCore to detect performance bottlenecks\nImport Timing Analysis: Analyze package loading times with @time_imports\nExplicit Imports Fixing: Automatically fix implicit imports and remove unused imports\nOrganization-wide Operations: Process entire organizations at once","category":"page"},{"location":"#Usage-Examples","page":"Home","title":"Usage Examples","text":"","category":"section"},{"location":"#Code-Formatting","page":"Home","title":"Code Formatting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OrgMaintenanceScripts\n\n# Format a single repository\nsuccess, message, pr_url = format_repository(\n    \"https://github.com/SciML/Example.jl.git\";\n    fork_user = \"myusername\"\n)\n\n# Format all repos with failing CI\nsuccesses, failures, pr_urls = format_org_repositories(\n    \"SciML\";\n    fork_user = \"myusername\",\n    only_failing_ci = true\n)","category":"page"},{"location":"#Version-Bumping-and-Registration","page":"Home","title":"Version Bumping and Registration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OrgMaintenanceScripts\n\n# Bump minor versions and register all packages in a repository\nresult = bump_and_register_repo(\"/path/to/repo\")\n\nprintln(\"Registered packages: \", result.registered)\nprintln(\"Failed packages: \", result.failed)\n\n# Process all repositories in the SciML organization\nresults = bump_and_register_org(\"SciML\"; auth_token=\"your_github_token\")\n\nfor (repo, result) in results\n    println(\"$repo:\")\n    println(\"  Registered: \", result.registered)\n    println(\"  Failed: \", result.failed)\nend","category":"page"},{"location":"#Minimum-Version-Fixing","page":"Home","title":"Minimum Version Fixing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OrgMaintenanceScripts\n\n# Fix minimum versions for a single repository\nsuccess = fix_repo_min_versions(\"SciML/OrdinaryDiffEq.jl\")\n\n# Fix all repositories in an organization\nresults = fix_org_min_versions(\"SciML\")\n\n# Process only specific repositories\nresults = fix_org_min_versions(\"SciML\"; only_repos=[\"OrdinaryDiffEq.jl\", \"DiffEqBase.jl\"])","category":"page"},{"location":"#Compat-Bumping","page":"Home","title":"Compat Bumping","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OrgMaintenanceScripts\n\n# Check available compat updates for a repository\nupdates = get_available_compat_updates(\"/path/to/MyPackage.jl\")\nfor (pkg, info) in updates\n    println(\"$pkg: $(info.current) → $(info.latest)\")\nend\n\n# Bump compat bounds and test\nsuccess = bump_compat_and_test(\"/path/to/MyPackage.jl\"; \n    create_pr = true,\n    fork_user = \"myusername\"\n)\n\n# Process an entire organization\nresults = bump_compat_org_repositories(\"SciML\";\n    fork_user = \"myusername\",\n    limit = 10\n)","category":"page"},{"location":"#Version-Check-Finding","page":"Home","title":"Version Check Finding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OrgMaintenanceScripts\n\n# Find old version checks in a repository\nchecks = find_version_checks_in_repo(\"/path/to/MyPackage.jl\")\n\n# Find old version checks across an organization\nresults = find_version_checks_in_org(\"SciML\"; min_version=v\"1.10\")\nprint_version_check_summary(results)\n\n# Use custom minimum version\nresults = find_version_checks_in_org(\"MyOrg\"; min_version=v\"1.9\", max_repos=10)","category":"page"},{"location":"#Explicit-Imports-Fixing","page":"Home","title":"Explicit Imports Fixing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OrgMaintenanceScripts\n\n# Fix explicit imports in a package\nsuccess, iterations, report = fix_explicit_imports(\"/path/to/MyPackage.jl\")\n\n# Fix and create PR for a repository\nfix_repo_explicit_imports(\"MyOrg/MyPackage.jl\"; create_pr=true)\n\n# Fix all packages in an organization\nresults = fix_org_explicit_imports(\"MyOrg\"; create_prs=true)","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"formatting.md\", \"version_bumping.md\", \"compat_bumping.md\", \"min_version_fixing.md\", \"version_check_finder.md\", \"invalidation_analysis.md\", \"import_timing_analysis.md\", \"explicit_imports_fixing.md\"]\nDepth = 2","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#OrgMaintenanceScripts.CompatUpdate","page":"Home","title":"OrgMaintenanceScripts.CompatUpdate","text":"CompatUpdate\n\nStruct to hold information about a potential compat update.\n\n\n\n\n\n","category":"type"},{"location":"#OrgMaintenanceScripts.analyze_import_timing_in_process","page":"Home","title":"OrgMaintenanceScripts.analyze_import_timing_in_process","text":"analyze_import_timing_in_process(repo_path::String, package_name::String=\"\")\n\nRun import timing analysis in a separate Julia process using @time_imports. Returns timing data for all packages involved in the import.\n\n\n\n\n\n","category":"function"},{"location":"#OrgMaintenanceScripts.analyze_invalidations_in_process","page":"Home","title":"OrgMaintenanceScripts.analyze_invalidations_in_process","text":"analyze_invalidations_in_process(repo_path::String, test_script::String=\"\")\n\nRun invalidation analysis in a separate Julia process to avoid contaminating the current session. Returns invalidation data that can be analyzed to find major invalidators.\n\n\n\n\n\n","category":"function"},{"location":"#OrgMaintenanceScripts.analyze_major_invalidators-Tuple{Dict}","page":"Home","title":"OrgMaintenanceScripts.analyze_major_invalidators","text":"analyze_major_invalidators(invalidation_data::Dict)\n\nAnalyze invalidation data to identify the major invalidators. Returns a list of the most problematic invalidations.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.analyze_org_import_timing-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.analyze_org_import_timing","text":"analyze_org_import_timing(org::String; auth_token::String=\"\", work_dir::String=mktempdir(), \n                         output_dir::String=\"\", max_repos::Int=0)\n\nAnalyze import timing across all repositories in a GitHub organization.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.analyze_org_invalidations-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.analyze_org_invalidations","text":"analyze_org_invalidations(org::String; auth_token::String=\"\", work_dir::String=mktempdir(), \n                         test_script::String=\"\", output_dir::String=\"\", max_repos::Int=0)\n\nAnalyze invalidations across all repositories in a GitHub organization.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.analyze_repo_import_timing-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.analyze_repo_import_timing","text":"analyze_repo_import_timing(repo_path::String; package_name::String=\"\", output_file::String=\"\")\n\nAnalyze import timing in a single repository and optionally save a report.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.analyze_repo_invalidations-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.analyze_repo_invalidations","text":"analyze_repo_invalidations(repo_path::String; test_script::String=\"\", output_file::String=\"\")\n\nAnalyze invalidations in a single repository and optionally save a report.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.bump_and_register_org-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.bump_and_register_org","text":"bump_and_register_org(org::String; \n                     registry_url=\"https://github.com/JuliaRegistries/General\",\n                     auth_token::String=\"\",\n                     work_dir::String=mktempdir())\n\nBump minor versions and register all packages in all repositories of a GitHub organization.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.bump_and_register_repo-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.bump_and_register_repo","text":"bump_and_register_repo(repo_path::String; registry_url=\"https://github.com/JuliaRegistries/General\")\n\nBump minor versions and register all packages in a repository. This handles the main Project.toml and all lib/*/Project.toml files.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.bump_compat_and_test-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.bump_compat_and_test","text":"bump_compat_and_test(repo_path::String;\n                    package_name::Union{String,Nothing} = nothing,\n                    bump_all::Bool = false,\n                    create_pr::Bool = true,\n                    fork_user::String = \"\")\n\nBump compat entries for major version updates and run tests. If tests pass, optionally create a PR.\n\nArguments\n\nrepo_path: Path to the repository\npackage_name: Specific package to bump (if nothing, check all)\nbump_all: Whether to bump all available updates or just one\ncreate_pr: Whether to create a PR if tests pass\nfork_user: GitHub username for creating PRs (required if create_pr=true)\n\nReturns\n\n(success::Bool, message::String, pr_url::Union{String,Nothing}, bumped_packages::Vector{String})\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.bump_compat_and_test_all-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.bump_compat_and_test_all","text":"bump_compat_and_test_all(repo_path::String;\n                        package_name::Union{String,Nothing} = nothing,\n                        bump_all::Bool = false,\n                        create_pr::Bool = true,\n                        fork_user::String = \"\",\n                        include_subpackages::Bool = true)\n\nBump compat entries for major version updates in all Project.toml files in a repository. This function supports repositories with subpackages in the /lib directory.\n\nArguments\n\nrepo_path: Path to the repository\npackage_name: Specific package to bump across all Project.toml files\nbump_all: Whether to bump all available updates or just one per Project.toml\ncreate_pr: Whether to create a PR if tests pass\nfork_user: GitHub username for creating PRs (required if create_pr=true)\ninclude_subpackages: Whether to include subpackages in /lib directory\n\nReturns\n\n(success::Bool, message::String, pr_url::Union{String,Nothing}, bumped_info::Dict)\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.bump_compat_entry-Tuple{String, String, String}","page":"Home","title":"OrgMaintenanceScripts.bump_compat_entry","text":"bump_compat_entry(project_path::String, package_name::String, new_version::String)\n\nBump a single compat entry in Project.toml to allow the new version.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.bump_compat_org_repositories","page":"Home","title":"OrgMaintenanceScripts.bump_compat_org_repositories","text":"bump_compat_org_repositories(org::String = \"SciML\";\n                            package_name::Union{String,Nothing} = nothing,\n                            bump_all::Bool = false,\n                            create_pr::Bool = true,\n                            fork_user::String = \"\",\n                            limit::Int = 100,\n                            log_file::String = \"\",\n                            include_subpackages::Bool = true)\n\nBump compat entries for all repositories in a GitHub organization. This function now supports repositories with subpackages in /lib directories.\n\nArguments\n\norg: GitHub organization name (default: \"SciML\")\npackage_name: Specific package to bump across all repos (if nothing, check all)\nbump_all: Whether to bump all available updates or just one per repo\ncreate_pr: Whether to create PRs if tests pass\nfork_user: GitHub username for creating PRs (required if create_pr=true)\nlimit: Maximum number of repositories to process\nlog_file: Path to save results log (default: auto-generated)\ninclude_subpackages: Whether to include subpackages in /lib directories\n\nReturns\n\n(successes::Vector{String}, failures::Vector{String}, pr_urls::Vector{String})\n\n\n\n\n\n","category":"function"},{"location":"#OrgMaintenanceScripts.bump_compat_version-Tuple{String, String}","page":"Home","title":"OrgMaintenanceScripts.bump_compat_version","text":"bump_compat_version(compat_str::String, pkg_name::String)\n\nBump a compat version string conservatively, ensuring we don't go above the current release.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.bump_minor_version-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.bump_minor_version","text":"bump_minor_version(version_str::String) -> String\n\nBump the minor version of a semantic version string.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.create_compat_pr-Tuple{String, Vector{String}, String}","page":"Home","title":"OrgMaintenanceScripts.create_compat_pr","text":"create_compat_pr(repo_path::String, bumped_packages::Vector{String}, fork_user::String)\n\nCreate a pull request for compat updates.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.create_compat_pr_multi-Tuple{String, Dict{String, Vector{String}}, String}","page":"Home","title":"OrgMaintenanceScripts.create_compat_pr_multi","text":"create_compat_pr_multi(repo_path::String, bumped_info::Dict{String, Vector{String}}, fork_user::String)\n\nCreate a pull request for compat updates across multiple Project.toml files.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.downgrade_to_minimum_versions-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.downgrade_to_minimum_versions","text":"downgrade_to_minimum_versions(project_dir::String; julia_version=\"1.10\", mode=\"alldeps\", work_dir=mktempdir())\n\nDowngrade all dependencies to their minimum compatible versions using Resolver.jl. This uses the same approach as julia-actions/julia-downgrade-compat. Returns (success::Bool, output::String)\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.extract_min_version_from_compat-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.extract_min_version_from_compat","text":"extract_min_version_from_compat(compat_str::String)\n\nExtract the minimum version from a compat string.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.find_all_project_tomls-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.find_all_project_tomls","text":"find_all_project_tomls(repo_path::String)\n\nFind all Project.toml files in a repository, including those in the /lib subdirectory. Returns a vector of absolute paths to Project.toml files.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.find_files_to_fix-Tuple{String, Vector}","page":"Home","title":"OrgMaintenanceScripts.find_files_to_fix","text":"find_files_to_fix(package_path::String, issues::Vector)\n\nFind which files need to be fixed based on the issues found. Returns a Dict mapping file paths to their issues.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.find_version_checks_in_file-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.find_version_checks_in_file","text":"find_version_checks_in_file(filepath::String; min_version::VersionNumber=JULIA_LTS)\n\nFind all version checks in a single file that compare against versions older than min_version.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.find_version_checks_in_org-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.find_version_checks_in_org","text":"find_version_checks_in_org(org::String; \n                          min_version::VersionNumber=JULIA_LTS,\n                          auth_token::String=\"\",\n                          work_dir::String=mktempdir(),\n                          ignore_dirs=[\"test\", \"docs\", \".git\"])\n\nFind all version checks in all repositories of a GitHub organization.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.find_version_checks_in_repo-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.find_version_checks_in_repo","text":"find_version_checks_in_repo(repo_path::String; min_version::VersionNumber=JULIA_LTS, ignore_dirs=[\"test\", \"docs\", \".git\"])\n\nFind all version checks in a repository that compare against versions older than min_version.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.fix_explicit_imports-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.fix_explicit_imports","text":"fix_explicit_imports(package_path::String; max_iterations=10, verbose=true)\n\nIteratively fix explicit import issues in a package until all checks pass. Returns (success::Bool, iterations::Int, final_report::String)\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.fix_missing_import-Tuple{String, String, String}","page":"Home","title":"OrgMaintenanceScripts.fix_missing_import","text":"fix_missing_import(file_path::String, module_name::String, symbol::String)\n\nAdd a missing explicit import to a Julia file.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.fix_org_explicit_imports-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.fix_org_explicit_imports","text":"fix_org_explicit_imports(org_name::String;\n                        work_dir=mktempdir(),\n                        max_iterations=10,\n                        create_prs=true,\n                        skip_repos=String[],\n                        only_repos=nothing,\n                        verbose=true)\n\nFix explicit imports for all Julia packages in a GitHub organization.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.fix_org_min_versions-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.fix_org_min_versions","text":"fix_org_min_versions(org_name::String;\n                    work_dir=mktempdir(),\n                    max_iterations=10,\n                    create_prs=true,\n                    skip_repos=String[],\n                    only_repos=nothing,\n                    julia_version=\"1.10\",\n                    include_subpackages=true)\n\nFix minimum versions for all Julia packages in a GitHub organization. Now supports repositories with subpackages in /lib directories.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.fix_org_version_checks_parallel","page":"Home","title":"OrgMaintenanceScripts.fix_org_version_checks_parallel","text":"fix_org_version_checks_parallel(org::String, n_processes::Int=4;\n                               min_version::VersionNumber=JULIA_LTS,\n                               github_token::String=\"\",\n                               base_branch::String=\"main\",\n                               work_dir::String=mktempdir())\n\nFind and fix version checks across an entire GitHub organization using parallel processing.\n\n\n\n\n\n","category":"function"},{"location":"#OrgMaintenanceScripts.fix_package_min_versions-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.fix_package_min_versions","text":"fix_package_min_versions(repo_path::String; \n                        max_iterations=10, \n                        work_dir=mktempdir(),\n                        julia_version=\"1.10\")\n\nFix minimum versions for a package repository that's already cloned. Returns (success::Bool, updates::Dict{String,String})\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.fix_package_min_versions_all-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.fix_package_min_versions_all","text":"fix_package_min_versions_all(repo_path::String;\n                            max_iterations=10,\n                            work_dir=mktempdir(),\n                            julia_version=\"1.10\",\n                            include_subpackages=true)\n\nFix minimum versions for all Project.toml files in a repository. Supports repositories with subpackages in the /lib directory. Returns (success::Bool, all_updates::Dict{String,Dict{String,String}})\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.fix_repo_explicit_imports-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.fix_repo_explicit_imports","text":"fix_repo_explicit_imports(repo_name::String;\n                         work_dir=mktempdir(),\n                         max_iterations=10,\n                         create_pr=true,\n                         verbose=true)\n\nClone a repository, fix its explicit imports, and optionally create a PR.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.fix_repo_min_versions-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.fix_repo_min_versions","text":"fix_repo_min_versions(repo_name::String;\n                     work_dir=mktempdir(),\n                     max_iterations=10,\n                     create_pr=true,\n                     julia_version=\"1.10\",\n                     include_subpackages=true)\n\nClone a repository, fix its minimum versions, and optionally create a PR. Now supports repositories with subpackages in /lib directories.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.fix_unused_import-Tuple{String, String}","page":"Home","title":"OrgMaintenanceScripts.fix_unused_import","text":"fix_unused_import(file_path::String, symbol::String)\n\nRemove an unused import from a Julia file.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.fix_version_checks_parallel","page":"Home","title":"OrgMaintenanceScripts.fix_version_checks_parallel","text":"fix_version_checks_parallel(checks::Vector{VersionCheck}, n_processes::Int=4; \n                           github_token::String=\"\", \n                           base_branch::String=\"main\",\n                           pr_title_prefix::String=\"[Auto] Remove obsolete version checks\")\n\nFix version checks in parallel using N processes. Each process will create a PR  to fix the version checks by removing obsolete comparisons.\n\n\n\n\n\n","category":"function"},{"location":"#OrgMaintenanceScripts.format_org_repositories","page":"Home","title":"OrgMaintenanceScripts.format_org_repositories","text":"format_org_repositories(org::String = \"SciML\";\n                       test::Bool = true,\n                       push_to_master::Bool = false,\n                       create_pr::Bool = true,\n                       fork_user::String = \"\",\n                       limit::Int = 100,\n                       only_failing_ci::Bool = true,\n                       log_file::String = \"\")\n\nFormat all repositories in a GitHub organization.\n\nArguments\n\norg: GitHub organization name (default: \"SciML\")\ntest: Whether to run tests after formatting (default: true)\npush_to_master: Whether to push directly to master/main if tests pass (default: false)\ncreate_pr: Whether to create PRs instead of pushing to master (default: true)\nfork_user: GitHub username for creating PRs (required if create_pr=true)\nlimit: Maximum number of repositories to process (default: 100)\nonly_failing_ci: Only process repos with failing formatter CI (default: true)\nlog_file: Path to save results log (default: auto-generated)\n\nReturns\n\n(successes::Vector{String}, failures::Vector{String}, pr_urls::Vector{String})\n\n\n\n\n\n","category":"function"},{"location":"#OrgMaintenanceScripts.format_repository-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.format_repository","text":"format_repository(repo_url::String; \n                 test::Bool = true,\n                 push_to_master::Bool = false,\n                 create_pr::Bool = true,\n                 fork_user::String = \"\",\n                 working_dir::String = mktempdir())\n\nFormat a single repository with JuliaFormatter.\n\nArguments\n\nrepo_url: URL of the repository to format (e.g., \"https://github.com/SciML/Example.jl.git\")\ntest: Whether to run tests after formatting (default: true)\npush_to_master: Whether to push directly to master/main if tests pass (default: false)\ncreate_pr: Whether to create a PR instead of pushing to master (default: true)\nfork_user: GitHub username for creating PRs (required if create_pr=true)\nworking_dir: Directory to clone the repository into (default: temporary directory)\n\nReturns\n\n(success::Bool, message::String, pr_url::Union{String,Nothing})\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.generate_import_timing_report","page":"Home","title":"OrgMaintenanceScripts.generate_import_timing_report","text":"generate_import_timing_report(repo_path::String, package_name::String=\"\")\n\nGenerate a comprehensive import timing report for a repository.\n\n\n\n\n\n","category":"function"},{"location":"#OrgMaintenanceScripts.generate_invalidation_report","page":"Home","title":"OrgMaintenanceScripts.generate_invalidation_report","text":"generate_invalidation_report(repo_path::String, test_script::String=\"\")\n\nGenerate a comprehensive invalidation report for a repository.\n\n\n\n\n\n","category":"function"},{"location":"#OrgMaintenanceScripts.generate_org_import_summary_report-Tuple{String, Dict{String, ImportTimingReport}, String}","page":"Home","title":"OrgMaintenanceScripts.generate_org_import_summary_report","text":"generate_org_import_summary_report(org::String, results::Dict{String, ImportTimingReport}, output_dir::String)\n\nGenerate a summary report for import timing across the entire organization.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.generate_org_summary_report-Tuple{String, Dict{String, InvalidationReport}, String}","page":"Home","title":"OrgMaintenanceScripts.generate_org_summary_report","text":"generate_org_summary_report(org::String, results::Dict{String, InvalidationReport}, output_dir::String)\n\nGenerate a summary report for the entire organization.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.get_available_compat_updates-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.get_available_compat_updates","text":"get_available_compat_updates(project_path::String)\n\nCheck for available compat updates in a Project.toml file. Returns a vector of CompatUpdate structs.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.get_available_compat_updates_all-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.get_available_compat_updates_all","text":"get_available_compat_updates_all(repo_path::String)\n\nCheck for available compat updates in all Project.toml files in a repository. Returns a Dict mapping project paths to vectors of CompatUpdate structs.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.get_latest_package_version-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.get_latest_package_version","text":"get_latest_package_version(package_name::String)\n\nGet the latest version of a package from the General registry.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.get_latest_version-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.get_latest_version","text":"get_latest_version(pkg_name::String)\n\nGet the latest version of a package from the registry.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.get_org_repos-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.get_org_repos","text":"get_org_repos(org::String; auth_token::String=\"\")\n\nGet all repositories for a GitHub organization.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.get_org_repositories","page":"Home","title":"OrgMaintenanceScripts.get_org_repositories","text":"get_org_repositories(org::String, limit::Int = 100)\n\nGet all Julia repositories from a GitHub organization.\n\n\n\n\n\n","category":"function"},{"location":"#OrgMaintenanceScripts.get_project_info-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.get_project_info","text":"get_project_info(project_path::String)\n\nExtract package name and other information from a Project.toml file. Returns a NamedTuple with name, uuid, and path fields.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.get_relative_project_path-Tuple{String, String}","page":"Home","title":"OrgMaintenanceScripts.get_relative_project_path","text":"get_relative_project_path(project_path::String, repo_path::String)\n\nGet the relative path of a Project.toml file from the repository root.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.get_smart_min_version-Tuple{String, String}","page":"Home","title":"OrgMaintenanceScripts.get_smart_min_version","text":"get_smart_min_version(pkg_name::String, current_compat::String)\n\nGet an appropriate minimum version for a package.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.has_failing_formatter_ci-Tuple{String, String}","page":"Home","title":"OrgMaintenanceScripts.has_failing_formatter_ci","text":"has_failing_formatter_ci(org::String, repo::String)\n\nCheck if a repository has failing formatter CI.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.is_major_version_update-Tuple{String, String}","page":"Home","title":"OrgMaintenanceScripts.is_major_version_update","text":"is_major_version_update(current_compat::String, latest_version::String)\n\nCheck if the latest version is a major version update compared to current compat.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.is_outdated_compat-Tuple{String, String}","page":"Home","title":"OrgMaintenanceScripts.is_outdated_compat","text":"is_outdated_compat(compat_str::String, pkg_name::String)\n\nCheck if a compat string indicates an outdated version by comparing to the latest release.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.is_subpackage-Tuple{String, String}","page":"Home","title":"OrgMaintenanceScripts.is_subpackage","text":"is_subpackage(project_path::String, repo_path::String)\n\nCheck if a Project.toml file is a subpackage (i.e., in the /lib directory).\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.parse_compat_upper_bound-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.parse_compat_upper_bound","text":"parse_compat_upper_bound(compat_spec::String)\n\nParse a compat specification to extract the upper bound version.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.parse_explicit_imports_output-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.parse_explicit_imports_output","text":"parse_explicit_imports_output(output::String)\n\nParse the output from ExplicitImports checks to extract actionable issues. Returns a vector of issues with their types and details.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.parse_import_timings-Tuple{Dict}","page":"Home","title":"OrgMaintenanceScripts.parse_import_timings","text":"parse_import_timings(timing_data::Dict)\n\nParse the raw timing data and create structured ImportTiming objects.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.parse_resolution_errors-Tuple{String, Dict}","page":"Home","title":"OrgMaintenanceScripts.parse_resolution_errors","text":"parse_resolution_errors(output::String, project_toml::Dict)\n\nParse resolution errors to identify problematic packages.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.register_package-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.register_package","text":"register_package(package_dir::String; registry_url=\"https://github.com/JuliaRegistries/General\")\n\nRegister a Julia package to the specified registry.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.run_explicit_imports_check-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.run_explicit_imports_check","text":"run_explicit_imports_check(package_path::String; verbose=true)\n\nRun ExplicitImports.jl checks on a package and return the report. Returns (success::Bool, report::String, issues::Vector)\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.run_explicit_imports_check_all-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.run_explicit_imports_check_all","text":"run_explicit_imports_check_all(repo_path::String; verbose=true, include_subpackages=true)\n\nRun ExplicitImports.jl checks on all packages in a repository. Supports repositories with subpackages in /lib directories. Returns a Dict mapping relative paths to (success, report, issues) tuples.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.run_package_tests-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.run_package_tests","text":"run_package_tests(repo_path::String; timeout_minutes::Int = 30)\n\nRun tests for a Julia package and return whether they passed.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.run_tests-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.run_tests","text":"run_tests(repo_path::String; timeout_minutes::Int = 10)\n\nRun tests for a Julia package.\n\nReturns\n\ntrue if tests pass, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.setup_resolver-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.setup_resolver","text":"setup_resolver(work_dir::String)\n\nClone and setup Resolver.jl if not already present. Returns the path to Resolver.jl.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.test_min_versions-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.test_min_versions","text":"test_min_versions(project_dir::String; julia_version=\"1.10\", mode=\"alldeps\", work_dir=mktempdir())\n\nTest if minimum versions can be resolved using Resolver.jl. Returns (success::Bool, error_output::String)\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.update_compat!-Tuple{Dict, Dict{String, String}}","page":"Home","title":"OrgMaintenanceScripts.update_compat!","text":"update_compat!(project_toml::Dict, updates::Dict{String, String})\n\nUpdate the compat section preserving upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.update_project_version-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.update_project_version","text":"update_project_version(project_path::String)\n\nUpdate the version in a Project.toml file by bumping the minor version.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.update_project_versions_all-Tuple{String}","page":"Home","title":"OrgMaintenanceScripts.update_project_versions_all","text":"update_project_versions_all(repo_path::String; include_subpackages::Bool=true)\n\nUpdate the version in all Project.toml files in a repository by bumping the minor version. Supports repositories with subpackages in /lib directories. Returns a Dict mapping relative paths to (oldversion, newversion) tuples.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.write_import_timing_report-Tuple{ImportTimingReport, String}","page":"Home","title":"OrgMaintenanceScripts.write_import_timing_report","text":"write_import_timing_report(report::ImportTimingReport, output_file::String)\n\nWrite a detailed import timing report to a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.write_invalidation_report-Tuple{InvalidationReport, String}","page":"Home","title":"OrgMaintenanceScripts.write_invalidation_report","text":"write_invalidation_report(report::InvalidationReport, output_file::String)\n\nWrite a detailed invalidation report to a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"#OrgMaintenanceScripts.write_org_version_checks_to_script","page":"Home","title":"OrgMaintenanceScripts.write_org_version_checks_to_script","text":"write_org_version_checks_to_script(org_results::Dict{String, Vector{VersionCheck}}, output_file::String=\"fix_org_version_checks.jl\")\n\nWrite organization-wide version check results to a script file.\n\n\n\n\n\n","category":"function"},{"location":"#OrgMaintenanceScripts.write_version_checks_to_script","page":"Home","title":"OrgMaintenanceScripts.write_version_checks_to_script","text":"write_version_checks_to_script(checks::Vector{VersionCheck}, output_file::String=\"fix_version_checks.jl\")\n\nWrite version check results to a Julia script file that can be executed to fix them.\n\n\n\n\n\n","category":"function"}]
}
